#!/usr/bin/env node

import { promises as fs } from 'node:fs'
import { existsSync } from 'node:fs'
import { dirname, relative, resolve } from 'node:path'
import { fileURLToPath, pathToFileURL } from 'node:url'
import JSZip from 'jszip'
import { XMLParser } from 'fast-xml-parser'

const __filename = fileURLToPath(import.meta.url)
const __dirname = dirname(__filename)
const defaultRootDir = resolve(__dirname, '..')

const xmlParser = new XMLParser({
  ignoreAttributes: false,
  attributeNamePrefix: '',
  removeNSPrefix: true,
  trimValues: true,
})

function toArray(value) {
  if (Array.isArray(value)) return value
  if (value === undefined || value === null) return []
  return [value]
}

function getText(node) {
  if (typeof node === 'string') return node.trim() || null
  if (node && typeof node === 'object') {
    if (typeof node['#text'] === 'string') return node['#text'].trim() || null
    if (typeof node.text === 'string') return node.text.trim() || null
  }
  return null
}

function zipDirname(path) {
  const idx = path.lastIndexOf('/')
  return idx === -1 ? '' : path.slice(0, idx)
}

function joinZipPath(...segments) {
  const parts = []
  for (const segment of segments) {
    if (!segment) continue
    for (const part of segment.split('/')) {
      if (!part || part === '.') continue
      if (part === '..') {
        if (parts.length > 0) parts.pop()
        continue
      }
      parts.push(part)
    }
  }
  return parts.join('/')
}

function inferMimeType(href) {
  const ext = href.split('.').pop()?.toLowerCase()
  switch (ext) {
    case 'jpg':
    case 'jpeg':
      return 'image/jpeg'
    case 'png':
      return 'image/png'
    case 'gif':
      return 'image/gif'
    case 'webp':
      return 'image/webp'
    case 'svg':
      return 'image/svg+xml'
    case 'bmp':
      return 'image/bmp'
    default:
      return null
  }
}

async function writeManifest(filePath, entries) {
  const header = '// This file is auto-generated by scripts/generate-epub-manifest.mjs. Do not edit manually.\n'
  const content =
    header +
    `export const libraryBooks = ${JSON.stringify(entries, null, 2)};\n\n` +
    'export default libraryBooks;\n'

  await fs.mkdir(dirname(filePath), { recursive: true })
  await fs.writeFile(filePath, content, 'utf8')
}

async function extractEntry(filePath) {
  const buffer = await fs.readFile(filePath)
  const zip = await JSZip.loadAsync(buffer)

  const containerEntry = zip.file('META-INF/container.xml')
  if (!containerEntry) throw new Error('Missing META-INF/container.xml')

  const containerXml = await containerEntry.async('string')
  const container = xmlParser.parse(containerXml)
  const rootfiles =
    container?.container?.rootfiles?.rootfile ?? container?.rootfiles?.rootfile
  const rootfile = toArray(rootfiles)[0]
  const opfPath = rootfile?.['full-path'] ?? rootfile?.fullPath
  if (!opfPath) throw new Error('Missing OPF full-path in container.xml')

  const opfEntry = zip.file(opfPath)
  if (!opfEntry) throw new Error(`OPF file not found at ${opfPath}`)

  const opfXml = await opfEntry.async('string')
  const opf = xmlParser.parse(opfXml)
  const metadata = opf?.package?.metadata
  if (!metadata) throw new Error('Missing <metadata> section in OPF')

  const titles = toArray(metadata.title ?? metadata['dc:title'])
  const title = getText(titles[0])
  if (!title) throw new Error('Missing <dc:title> value')

  const creators = toArray(metadata.creator ?? metadata['dc:creator'])
  const author = getText(creators[0])

  const metaEntries = toArray(metadata.meta)
  const coverMeta = metaEntries.find((meta) => {
    const name = meta?.name ?? meta?.['@_name']
    return name === 'cover'
  })
  const coverId = coverMeta?.content ?? coverMeta?.['@_content']
  if (!coverId) throw new Error('Missing <meta name="cover" ...> declaration')

  const items = toArray(opf?.package?.manifest?.item)
  const coverItem = items.find((item) => {
    const id = item?.id ?? item?.['@_id']
    return id === coverId
  })
  if (!coverItem) throw new Error(`Cover item "${coverId}" not found in manifest`)

  const coverHref = coverItem.href ?? coverItem?.['@_href']
  if (!coverHref) throw new Error('Cover item missing href attribute')

  const mediaType =
    coverItem['media-type'] ??
    coverItem?.['@_media-type'] ??
    inferMimeType(coverHref)
  if (!mediaType) {
    throw new Error(`Unable to determine cover media type for ${coverHref}`)
  }
  if (!mediaType.startsWith('image/')) {
    throw new Error(`Cover media type is not an image (${mediaType})`)
  }

  const opfDir = zipDirname(opfPath)
  const coverZipPath = joinZipPath(opfDir, coverHref)
  const coverEntry = zip.file(coverZipPath)
  if (!coverEntry) {
    throw new Error(`Cover asset "${coverZipPath}" not found in archive`)
  }

  const coverBase64 = await coverEntry.async('base64')
  const coverUri = `data:${mediaType};base64,${coverBase64}`

  const entry = { title: title.trim() }
  if (author) entry.author = author.trim()
  entry.cover = { uri: coverUri }

  return entry
}

export async function generateEpubManifest({ rootDir = defaultRootDir } = {}) {
  const epubDir = resolve(rootDir, 'assets', 'epubs')
  const outputPath = resolve(rootDir, 'lib', 'epub-manifest.js')
  const entries = []

  if (!existsSync(epubDir)) {
    await writeManifest(outputPath, entries)
    return entries
  }

  const fileNames = await fs.readdir(epubDir)
  fileNames.sort((a, b) => a.localeCompare(b))

  for (const fileName of fileNames) {
    if (!fileName.toLowerCase().endsWith('.epub')) continue
    const fullPath = resolve(epubDir, fileName)
    const stat = await fs.stat(fullPath)
    if (!stat.isFile()) continue

    const relPath = relative(rootDir, fullPath)

    try {
      const entry = await extractEntry(fullPath)
      entries.push(entry)
    } catch (error) {
      console.warn(
        `[generate-epub-manifest] Skipped ${relPath}: ${error.message}`
      )
    }
  }

  await writeManifest(outputPath, entries)
  return entries
}

async function main() {
  const entries = await generateEpubManifest()
  const count = entries.length
  const noun = count === 1 ? 'entry' : 'entries'
  console.log(
    `[generate-epub-manifest] Wrote ${count} ${noun} to lib/epub-manifest.js`
  )
}

const isMainModule =
  process.argv[1] &&
  pathToFileURL(process.argv[1]).href === import.meta.url

if (isMainModule) {
  main().catch((error) => {
    console.error(`[generate-epub-manifest] ${error.message}`)
    process.exit(1)
  })
}
